name: ğŸ“Š Advanced Test Report

on:
  pull_request:
    branches: [main, dev, develop]

permissions:
  contents: read
  pull-requests: write
  checks: write

jobs:
  test-report:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          
      - name: Install pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8
          run_install: false
          
      - name: Install dependencies
        run: pnpm install --no-frozen-lockfile
        
      - name: Run tests with detailed reporting
        run: |
          echo "ğŸ§ª Starting test execution..."
          
          # í…ŒìŠ¤íŠ¸ íŒŒì¼ íƒì§€ í™•ì¸
          echo "ğŸ“ Test files found:"
          find src -name "*.test.*" -type f | tee test-files.txt
          echo "ğŸ“Š Total test files: $(cat test-files.txt | wc -l)"
          
          # CI í™˜ê²½ ì •ë³´ ì¶œë ¥
          echo "ğŸ”§ CI Environment info:"
          echo "  Node version: $(node --version)"
          echo "  npm version: $(npm --version)"
          echo "  pnpm version: $(pnpm --version)"
          echo "  Working directory: $(pwd)"
          
          # JSON ë¦¬í¬í„°ë¡œ í…ŒìŠ¤íŠ¸ ì‹¤í–‰
          echo "ğŸƒ Running tests with JSON reporter..."
          pnpm test --reporter=json > test-results.json 2>&1
          TEST_EXIT_CODE=$?
          echo "ğŸ“‹ Test exit code: $TEST_EXIT_CODE"
          
          # ë‹¤ì–‘í•œ ë¦¬í¬í„°ë¡œ í…ŒìŠ¤íŠ¸ ì‹¤í–‰ (ë” ìì„¸í•œ ì¶œë ¥)
          echo "ğŸƒ Running tests with verbose reporter..."
          pnpm test --reporter=verbose > test-verbose.txt 2>&1
          VERBOSE_EXIT_CODE=$?
          echo "ğŸ“‹ Verbose test exit code: $VERBOSE_EXIT_CODE"
          
          # ê¸°ë³¸ ë¦¬í¬í„°ë¡œë„ í…ŒìŠ¤íŠ¸ ì‹¤í–‰
          echo "ğŸƒ Running tests with default reporter..."
          pnpm test > test-default.txt 2>&1
          DEFAULT_EXIT_CODE=$?
          echo "ğŸ“‹ Default test exit code: $DEFAULT_EXIT_CODE"
          
          # ì»¤ë²„ë¦¬ì§€ ì‹¤í–‰ (ë³„ë„ë¡œ)
          echo "ğŸ“Š Running coverage..."
          pnpm test:coverage > coverage-output.txt 2>&1 || echo "Coverage failed"
          
          echo "ğŸ“ Checking all output files..."
          for file in test-results.json test-verbose.txt test-default.txt coverage-output.txt; do
            if [ -f "$file" ]; then
              echo "âœ… $file: $(wc -c < "$file") bytes"
            else
              echo "âŒ $file: Not found"
            fi
          done
          
          echo "ğŸ“„ JSON file content (first 500 chars):"
          head -c 500 test-results.json 2>/dev/null || echo "No JSON file"
          
          echo "ğŸ“„ Verbose file content (first 1000 chars):"
          head -c 1000 test-verbose.txt 2>/dev/null || echo "No verbose file"
          
          echo "ğŸ“„ Default file content (first 1000 chars):"
          head -c 1000 test-default.txt 2>/dev/null || echo "No default file"
        continue-on-error: true
        
      - name: Parse test results and generate report
        id: test_results
        run: |
          node -e "
            const fs = require('fs');
            const path = require('path');
            
            let summary = {
              totalTests: 0,
              passedTests: 0,
              failedTests: 0,
              skippedTests: 0,
              testFiles: 0,
              runtime: 0,
              coverage: {
                lines: 0,
                functions: 0,
                branches: 0,
                statements: 0
              },
              failedTestDetails: []
            };
            
            try {
              console.log('ğŸ” Starting test result parsing...');
              
              // ì»¤ë²„ë¦¬ì§€ ë°ì´í„° íŒŒì‹±
              if (fs.existsSync('./coverage/coverage-summary.json')) {
                try {
                  const coverageData = JSON.parse(fs.readFileSync('./coverage/coverage-summary.json', 'utf8'));
                  if (coverageData.total) {
                    summary.coverage = {
                      lines: coverageData.total.lines?.pct || 0,
                      functions: coverageData.total.functions?.pct || 0,
                      branches: coverageData.total.branches?.pct || 0,
                      statements: coverageData.total.statements?.pct || 0
                    };
                    console.log('âœ… Coverage data parsed successfully');
                  }
                } catch (e) {
                  console.log('âŒ Coverage data parsing failed:', e.message);
                }
              }
              
              // ì—¬ëŸ¬ ì¶œë ¥ íŒŒì¼ì„ ì‹œë„í•˜ì—¬ íŒŒì‹±
              const outputFiles = ['test-default.txt', 'test-verbose.txt', 'coverage-output.txt'];
              let parseSuccess = false;
              
              for (const fileName of outputFiles) {
                if (fs.existsSync(\`./$\{fileName}\`) && !parseSuccess) {
                  const content = fs.readFileSync(\`./$\{fileName}\`, 'utf8');
                  console.log(\`\\nğŸ” Trying to parse $\{fileName} (length: $\{content.length})\\n\`);
                  console.log(\`ğŸ“„ Content preview (first 1200 chars):\\n$\{content.substring(0, 1200)}\`);
                  console.log('\\n--- End of preview ---\\n');
                  
                  // ë‹¤ì–‘í•œ vitest ê²°ê³¼ íŒ¨í„´ ì‹œë„
                  console.log(\`ğŸ” Attempting to match patterns in $\{fileName}...\`);
                  
                  // íŒ¨í„´ 1: í‘œì¤€ vitest ì¶œë ¥
                  const testFilesMatch1 = content.match(/Test Files\\s+(\\d+)\\s+passed\\s*\\((\\d+)\\)/);
                  const testsMatch1 = content.match(/Tests\\s+(\\d+)\\s+passed\\s*\\((\\d+)\\)/);
                  
                  // íŒ¨í„´ 2: ë‹¤ë¥¸ í˜•ì‹
                  const testFilesMatch2 = content.match(/(\\d+)\\s+passed.*test files?/i);
                  const testsMatch2 = content.match(/(\\d+)\\s+passed.*tests?\\s*$/gm);
                  
                  // íŒ¨í„´ 3: ì‹¤íŒ¨/ì„±ê³µ ì¹´ìš´íŠ¸
                  const failedTestsMatch = content.match(/(\\d+)\\s+failed/);
                  const skippedTestsMatch = content.match(/(\\d+)\\s+skipped/);
                  const durationMatch = content.match(/Duration\\s+([\\d.]+)(\\w+)/);
                  
                  // íŒ¨í„´ 4: ê°œë³„ í…ŒìŠ¤íŠ¸ íŒŒì¼ ì¹´ìš´íŠ¸
                  const individualTestMatches = content.match(/âœ“\\s+src\\/.+?\\((\\d+)\\s+tests?\\)/g);
                  
                  console.log(\`ğŸ“‹ Regex match results for $\{fileName}:\`);
                  console.log('  testFilesMatch1:', testFilesMatch1);
                  console.log('  testsMatch1:', testsMatch1);
                  console.log('  testFilesMatch2:', testFilesMatch2);
                  console.log('  testsMatch2:', testsMatch2);
                  console.log('  failedTestsMatch:', failedTestsMatch);
                  console.log('  skippedTestsMatch:', skippedTestsMatch);
                  console.log('  durationMatch:', durationMatch);
                  console.log('  individualTestMatches:', individualTestMatches);
                  
                  // ì²« ë²ˆì§¸ íŒ¨í„´ ì‹œë„
                  if (testFilesMatch1) {
                    summary.testFiles = parseInt(testFilesMatch1[1]);
                    parseSuccess = true;
                    console.log(\`ğŸ“ Test files (pattern 1): $\{summary.testFiles}\`);
                  } else if (testFilesMatch2) {
                    summary.testFiles = parseInt(testFilesMatch2[1]);
                    parseSuccess = true;
                    console.log(\`ğŸ“ Test files (pattern 2): $\{summary.testFiles}\`);
                  }
                  
                  if (testsMatch1) {
                    summary.passedTests = parseInt(testsMatch1[1]);
                    summary.totalTests = summary.passedTests;
                    parseSuccess = true;
                    console.log(\`âœ… Passed tests (pattern 1): $\{summary.passedTests}\`);
                  } else if (testsMatch2 && testsMatch2.length > 0) {
                    // ë§ˆì§€ë§‰ ë§¤ì¹˜ê°€ ì´ í…ŒìŠ¤íŠ¸ ìˆ˜ì¼ ê°€ëŠ¥ì„±ì´ ë†’ìŒ
                    const lastMatch = testsMatch2[testsMatch2.length - 1];
                    const match = lastMatch.match(/(\\d+)/);
                    if (match) {
                      summary.passedTests = parseInt(match[1]);
                      summary.totalTests = summary.passedTests;
                      parseSuccess = true;
                      console.log(\`âœ… Passed tests (pattern 2): $\{summary.passedTests}\`);
                    }
                  }
                  
                  // ê°œë³„ í…ŒìŠ¤íŠ¸ íŒŒì¼ì—ì„œ ì¹´ìš´íŠ¸ (ë°±ì—… ë°©ë²•)
                  if (individualTestMatches && !parseSuccess) {
                    let totalFromFiles = 0;
                    let fileCount = 0;
                    console.log('ğŸ” Parsing individual test file results...');
                    individualTestMatches.forEach(result => {
                      const match = result.match(/\\((\\d+)\\s+tests?\\)/);
                      if (match) {
                        const count = parseInt(match[1]);
                        totalFromFiles += count;
                        fileCount++;
                        console.log(\`  Found $\{count} tests in file\`);
                      }
                    });
                    
                    if (totalFromFiles > 0) {
                      console.log(\`ğŸ”„ Using file-based parsing: $\{totalFromFiles} total tests across $\{fileCount} files\`);
                      summary.totalTests = totalFromFiles;
                      summary.passedTests = totalFromFiles; // ì‹¤íŒ¨í•œ í…ŒìŠ¤íŠ¸ê°€ ì—†ë‹¤ê³  ê°€ì •
                      summary.testFiles = fileCount;
                      parseSuccess = true;
                    }
                  }
                  
                  // ì‹¤íŒ¨/ìŠ¤í‚µ í…ŒìŠ¤íŠ¸ íŒŒì‹±
                  if (failedTestsMatch) {
                    summary.failedTests = parseInt(failedTestsMatch[1]);
                    summary.totalTests += summary.failedTests;
                    console.log(\`âŒ Failed tests: $\{summary.failedTests}\`);
                  }
                  
                  if (skippedTestsMatch) {
                    summary.skippedTests = parseInt(skippedTestsMatch[1]);
                    summary.totalTests += summary.skippedTests;
                    console.log(\`â­ï¸ Skipped tests: $\{summary.skippedTests}\`);
                  }
                  
                  if (durationMatch) {
                    const duration = parseFloat(durationMatch[1]);
                    const unit = durationMatch[2];
                    summary.runtime = unit === 's' ? duration * 1000 : duration;
                    console.log(\`â±ï¸ Duration: $\{duration}$\{unit}\`);
                  }
                  
                  if (parseSuccess) {
                    console.log(\`ğŸ¯ Successfully parsed from $\{fileName}\`);
                    break;
                  }
                }
              }
              
              if (!parseSuccess) {
                console.log('âš ï¸ Could not parse test results from any output file, trying fallback methods...');
                
                // ìµœí›„ì˜ ìˆ˜ë‹¨: í…ŒìŠ¤íŠ¸ íŒŒì¼ ê°œìˆ˜ë¼ë„ ì¹´ìš´íŠ¸
                if (fs.existsSync('./test-files.txt')) {
                  const testFilesContent = fs.readFileSync('./test-files.txt', 'utf8');
                  const testFileLines = testFilesContent.trim().split('\\n').filter(line => line.trim());
                  summary.testFiles = testFileLines.length;
                  console.log(\`ğŸ“ Fallback: Found $\{summary.testFiles} test files\`);
                }
              }
              
              // JSON ê²°ê³¼ë„ ì‹œë„ (ì¶”ê°€ ì •ë³´ í™•ì¸ìš©)
              if (fs.existsSync('./test-results.json')) {
                try {
                  const content = fs.readFileSync('./test-results.json', 'utf8').trim();
                  console.log('ğŸ” JSON content length:', content.length);
                  console.log('ğŸ” JSON content start:', content.substring(0, 300));
                  
                  if (content && content.startsWith('{')) {
                    const testData = JSON.parse(content);
                    console.log('ğŸ” JSON structure keys:', Object.keys(testData));
                    
                    // JSONì—ì„œ ë” ì •í™•í•œ ì •ë³´ê°€ ìˆë‹¤ë©´ ì—…ë°ì´íŠ¸
                    if (testData.numTotalTests && testData.numTotalTests > summary.totalTests) {
                      summary.totalTests = testData.numTotalTests;
                      summary.passedTests = testData.numPassedTests || 0;
                      summary.failedTests = testData.numFailedTests || 0;
                      summary.skippedTests = testData.numPendingTests || 0;
                      console.log('ğŸ”„ Updated from JSON - Total:', summary.totalTests);
                    }
                  }
                } catch (e) {
                  console.log('âš ï¸ JSON parsing failed (expected for non-JSON output):', e.message);
                }
              }
              
              console.log('ğŸ“Š Final parsed summary:', JSON.stringify(summary, null, 2));
              
              // ì„±ëŠ¥ ë° ì»¤ë²„ë¦¬ì§€ ì²´í¬
              const performanceWarnings = [];
              if (summary.runtime > 30000) {
                performanceWarnings.push('âš ï¸ Tests took longer than 30 seconds');
              }
              
              const coverageWarnings = [];
              Object.entries(summary.coverage).forEach(([metric, value]) => {
                if (value < 80) {
                  coverageWarnings.push(\`âš ï¸ \${metric.charAt(0).toUpperCase() + metric.slice(1)} coverage is below 80% (\${value}%)\`);
                }
              });
              
              const emoji = summary.failedTests === 0 && summary.totalTests > 0 ? 'âœ…' : 
                           summary.totalTests === 0 ? 'âš ï¸' : 'âŒ';
              const testStatus = summary.totalTests === 0 ? 'NO TESTS FOUND' :
                                summary.failedTests === 0 ? 'ALL TESTS PASSED' : 'SOME TESTS FAILED';
              
              let comment = \`## \${emoji} Vitest Test Results
              
              **Status:** \${testStatus}
              \${summary.runtime > 0 ? \`**Runtime:** \${(summary.runtime / 1000).toFixed(2)}s\` : ''}
              
              ### ğŸ“Š Test Summary
              \\\`\\\`\\\`
              Test Files: \${summary.testFiles} files
              Total:      \${summary.totalTests} tests
              Passed:     \${summary.passedTests} tests
              Failed:     \${summary.failedTests} tests
              Skipped:    \${summary.skippedTests} tests
              \\\`\\\`\\\`
              \`;
              
              if (summary.coverage.lines > 0 || summary.coverage.functions > 0) {
                comment += \`
              ### ğŸ“ˆ Coverage Report
              | Metric | Coverage | Status |
              |--------|----------|--------|
              | Lines | \${summary.coverage.lines.toFixed(1)}% | \${summary.coverage.lines >= 80 ? 'âœ…' : 'âŒ'} |
              | Functions | \${summary.coverage.functions.toFixed(1)}% | \${summary.coverage.functions >= 80 ? 'âœ…' : 'âŒ'} |
              | Branches | \${summary.coverage.branches.toFixed(1)}% | \${summary.coverage.branches >= 80 ? 'âœ…' : 'âŒ'} |
              | Statements | \${summary.coverage.statements.toFixed(1)}% | \${summary.coverage.statements >= 80 ? 'âœ…' : 'âŒ'} |
              \`;
              }
              
              if (performanceWarnings.length > 0) {
                comment += \`\\n### â±ï¸ Performance Warnings\\n\` + performanceWarnings.join('\\n') + '\\n';
              }
              
              if (coverageWarnings.length > 0) {
                comment += \`\\n### ğŸ“‰ Coverage Warnings\\n\` + coverageWarnings.join('\\n') + '\\n';
              }
              
              if (summary.failedTestDetails.length > 0) {
                comment += \`\\n### âŒ Failed Tests\\n\`;
                summary.failedTestDetails.slice(0, 5).forEach(test => {
                  comment += \`\\n**\${test.file}**\\n\`;
                  comment += \`- \${test.test}\\n\`;
                  comment += \`\\\`\\\`\\\`\\n\${test.error.slice(0, 500)}...\\\`\\\`\\\`\\n\`;
                });
                
                if (summary.failedTestDetails.length > 5) {
                  comment += \`\\n*... and \${summary.failedTestDetails.length - 5} more failures*\\n\`;
                }
              } else if (summary.totalTests > 0 && summary.failedTests === 0) {
                comment += \`\\n### ğŸ‰ All tests passed!\\nGreat job! All \${summary.totalTests} tests are working correctly across \${summary.testFiles} test files.\\n\`;
              } else if (summary.totalTests === 0) {
                comment += \`\\n### âš ï¸ No tests found\\nMake sure your test files are properly configured and located in the right directories.\\n\`;
              }
              
              comment += \`\\n### ğŸ”— Quick Actions\\n\`;
              comment += \`- [ğŸ§ª Run tests locally](\\\`pnpm test\\\`)\\n\`;
              comment += \`- [ğŸ“Š Run coverage locally](\\\`pnpm test:coverage\\\`)\\n\`;
              comment += \`- [ğŸ¨ Open Vitest UI](\\\`pnpm test:ui\\\`)\\n\`;
              comment += \`- [âš™ï¸ View workflow logs](\${process.env.GITHUB_SERVER_URL}/\${process.env.GITHUB_REPOSITORY}/actions/runs/\${process.env.GITHUB_RUN_ID})\\n\`;
              
              comment += \`\\n---\\n*ğŸ¤– Generated by GitHub Actions at \${new Date().toISOString()}*\`;
              
              fs.writeFileSync('test-comment.md', comment);
              
              // GitHub Actions ì¶œë ¥
              const output = process.env.GITHUB_OUTPUT;
              if (output) {
                fs.appendFileSync(output, \`test_status=\${summary.failedTests === 0 && summary.totalTests > 0 ? 'success' : summary.totalTests === 0 ? 'neutral' : 'failure'}\\n\`);
                fs.appendFileSync(output, \`total_tests=\${summary.totalTests}\\n\`);
                fs.appendFileSync(output, \`failed_tests=\${summary.failedTests}\\n\`);
                fs.appendFileSync(output, \`test_files=\${summary.testFiles}\\n\`);
              }
              
            } catch (error) {
              console.error('ğŸ’¥ Error in test parsing:', error);
              console.error('ğŸ“‹ Stack trace:', error.stack);
              
              const fallbackComment = \`## âš ï¸ Test Parsing Error
              
              Could not parse test results properly. The tests may have run but results couldn't be processed.
              
              **Debugging info:**
              - Error: \${error.message}
              - Check the [workflow logs](\${process.env.GITHUB_SERVER_URL}/\${process.env.GITHUB_REPOSITORY}/actions/runs/\${process.env.GITHUB_RUN_ID}) for details
              
              **Next steps:**
              - Run tests locally: \\\`pnpm test\\\`
              - Check vitest configuration in \\\`vite.config.ts\\\`
              - Verify test files are in the correct location
              
              ---
              *ğŸ¤– Generated by GitHub Actions*\`;
              
              fs.writeFileSync('test-comment.md', fallbackComment);
              
              const output = process.env.GITHUB_OUTPUT;
              if (output) {
                fs.appendFileSync(output, 'test_status=error\\n');
              }
            }
          "
        
      - name: Comment PR with results
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const comment = fs.readFileSync('test-comment.md', 'utf8');
            
            // ê¸°ì¡´ í…ŒìŠ¤íŠ¸ ë¦¬í¬íŠ¸ ëŒ“ê¸€ ì°¾ê¸°
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.find(comment => 
              comment.user.login === 'github-actions[bot]' && 
              comment.body.includes('Vitest Test Results')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
            }
            
      - name: Create Check Run
        uses: actions/github-script@v7
        if: always()
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const testStatus = '${{ steps.test_results.outputs.test_status }}';
            const totalTests = '${{ steps.test_results.outputs.total_tests }}' || '0';
            const failedTests = '${{ steps.test_results.outputs.failed_tests }}' || '0';
            
            const conclusion = testStatus === 'success' ? 'success' : 
                             testStatus === 'error' ? 'neutral' : 'failure';
            
            const title = testStatus === 'success' 
              ? `âœ… All ${totalTests} tests passed!`
              : testStatus === 'error'
              ? 'âš ï¸ Test execution error'
              : `âŒ ${failedTests}/${totalTests} tests failed`;
            
            const summary = testStatus === 'success' 
              ? `ğŸ‰ All ${totalTests} tests are passing! Great job!`
              : testStatus === 'error'
              ? 'âš ï¸ Unable to execute tests properly. Check the workflow logs for details.'
              : `ğŸ“Š **Test Results Summary**\n- Total: ${totalTests} tests\n- Failed: ${failedTests} tests\n- Check the PR comment for detailed results.`;
            
            try {
              await github.rest.checks.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                name: 'Vitest Test Results',
                head_sha: context.payload.pull_request.head.sha,
                status: 'completed',
                conclusion: conclusion,
                output: {
                  title: title,
                  summary: summary,
                  text: 'See the PR comment for detailed test results and coverage information.'
                }
              });
            } catch (error) {
              console.log('Could not create check run:', error.message);
              // ì²´í¬ ì‹¤í–‰ ìƒì„±ì— ì‹¤íŒ¨í•´ë„ ì›Œí¬í”Œë¡œìš°ëŠ” ê³„ì† ì§„í–‰
            } 